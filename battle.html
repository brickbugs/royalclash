<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Clash Royale Clone - Battle</title>
<style>
  body, html {
    margin: 0; padding: 0; height: 100%; background: #181818; color: white; font-family: Arial, sans-serif;
    user-select: none;
    overflow: hidden;
  }
  #battleArea {
    position: relative;
    width: 100vw;
    height: 100vh;
    display: flex;
    flex-direction: column;
  }
  #map {
    flex-grow: 1;
    background: linear-gradient(to top, #0b5700 0%, #147b00 100%);
    position: relative;
    cursor: crosshair;
  }
  #map::before {
    content: "";
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    height: 3px;
    background: rgba(255, 255, 255, 0.2);
  }
  #hand {
    height: 140px;
    background: #222;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px;
    gap: 15px;
    box-shadow: 0 -5px 15px rgba(0,0,0,0.7);
  }
  .card {
    background: #444;
    border-radius: 12px;
    width: 80px;
    height: 110px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 24px;
    font-weight: bold;
    color: white;
    box-shadow: 0 3px 6px rgba(0,0,0,0.8);
    user-select: none;
    transition: transform 0.2s ease;
    cursor: pointer;
    position: relative;
  }
  .card.selected {
    outline: 3px solid #4caf50;
    transform: scale(1.1);
  }
  /* Placed cards on map */
  .placed-card {
    position: absolute;
    width: 60px;
    height: 80px;
    background: #4caf50cc;
    border-radius: 10px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    color: #fff;
    pointer-events: none;
    user-select: none;
  }
  .hp-bar-container {
    position: absolute;
    top: 5px;
    left: 50%;
    transform: translateX(-50%);
    width: 70%;
    height: 8px;
    background: #333;
    border-radius: 4px;
  }
  .hp-bar {
    height: 100%;
    background: #0f0;
    border-radius: 4px;
    width: 100%;
  }
  #startText {
    position: absolute;
    top: 10px;
    width: 100%;
    text-align: center;
    font-size: 22px;
    color: #0f0;
    pointer-events: none;
    user-select: none;
    z-index: 100;
  }
  /* Player names at top of map */
  #playerNames {
    position: absolute;
    top: 10px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    padding: 0 30px;
    font-size: 18px;
    color: white;
    pointer-events: none;
    user-select: none;
    z-index: 100;
  }
</style>
</head>
<body>
  <div id="battleArea">
    <div id="map" title="Click your area to place card">
      <div id="playerNames">
        <div id="player1Name">Player 1</div>
        <div id="player2Name">Player 2</div>
      </div>
      <div id="startText">Loading battle...</div>
    </div>
    <div id="hand"></div>
  </div>

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyADqsChcYfhT_bAlQ1VWkrlga-oTJViz7U",
      authDomain: "clashroyaleclone-ae764.firebaseapp.com",
      projectId: "clashroyaleclone-ae764",
      storageBucket: "clashroyaleclone-ae764.appspot.com",
      messagingSenderId: "938364278081",
      appId: "1:938364278081:web:1c214bd66caef6d7567dc0",
      measurementId: "G-PT2GPP0JF5"
    };

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    const lobbyId = localStorage.getItem("lobbyId");

    // Elements
    const startText = document.getElementById("startText");
    const player1NameEl = document.getElementById("player1Name");
    const player2NameEl = document.getElementById("player2Name");
    const map = document.getElementById("map");
    const hand = document.getElementById("hand");

    let currentUser = null;
    let playerDeck = [];
    let selectedCardIndex = null;
    let selectedCardData = null;

    // All placed cards on map
    // Each: { id, owner, x, y, hp, maxHp, damage, targets:[], domElement, hpBarElement }
    let placedCards = [];

    // Towers - fixed positions and HP for both players
    let towers = {
      player1: [
        {id: "p1-tower1", x: 100, y: 100, hp: 500, maxHp: 500, owner: "player1", targets: ["buildings"], domElement: null, hpBarElement: null},
        {id: "p1-tower2", x: 300, y: 100, hp: 500, maxHp: 500, owner: "player1", targets: ["buildings"], domElement: null, hpBarElement: null},
        {id: "p1-tower3", x: 500, y: 100, hp: 500, maxHp: 500, owner: "player1", targets: ["buildings"], domElement: null, hpBarElement: null}
      ],
      player2: [
        {id: "p2-tower1", x: 100, y: 350, hp: 500, maxHp: 500, owner: "player2", targets: ["buildings"], domElement: null, hpBarElement: null},
        {id: "p2-tower2", x: 300, y: 350, hp: 500, maxHp: 500, owner: "player2", targets: ["buildings"], domElement: null, hpBarElement: null},
        {id: "p2-tower3", x: 500, y: 350, hp: 500, maxHp: 500, owner: "player2", targets: ["buildings"], domElement: null, hpBarElement: null}
      ]
    };

    // Card data cache from Firestore "cards" collection
    // Format expected: document id = card name, fields: hitpoints, damage, targets, etc.
    let cardDataCache = {};

    // Load card data from firestore
    async function loadCardData() {
      const cardsSnapshot = await db.collection("cards").get();
      cardsSnapshot.forEach(doc => {
        const data = doc.data();
        cardDataCache[doc.id] = {
          name: data.name || doc.id,
          hitpoints: data.hitpoints || 100,
          damage: data.damage || 10,
          targets: (data.targets || "ground").split(",").map(t => t.trim()),
          elixir: data.elixir || 1,
          bio: data.bio || "",
          count: data.count || 1,
          speed: data.speed || "medium",
          range: data.range || "melee",
          hitspeed: data.hitspeed || 1.0
        };
      });
    }
function parseSpeed(speedStr) {
  switch((speedStr || '').toLowerCase()) {
    case "slow": return 30;
    case "medium": return 60;
    case "fast": return 120;
    default:
      let n = parseFloat(speedStr);
      return isNaN(n) ? 60 : n;
  }
}

function parseRange(rangeStr) {
  switch((rangeStr || '').toLowerCase()) {
    case "melee": return 40;
    case "short": return 80;
    case "medium": return 150;
    case "long": return 250;
    default:
      let n = parseFloat(rangeStr);
      return isNaN(n) ? 50 : n;
  }
}

    async function loadBattle() {
      if (!lobbyId) {
        startText.textContent = "❌ Lobby ID not found.";
        return;
      }

      try {
        const lobbySnap = await db.collection("lobbies").doc(lobbyId).get();
        const lobbyData = lobbySnap.data();
        if (!lobbyData || lobbyData.players.length < 2) {
          startText.textContent = "❌ Waiting for opponent...";
          return;
        }

        const [uid1, uid2] = lobbyData.players;

        // Load player data
        const [player1Snap, player2Snap] = await Promise.all([
          db.collection("players").doc(uid1).get(),
          db.collection("players").doc(uid2).get(),
        ]);

        const player1 = player1Snap.data();
        const player2 = player2Snap.data();

        player1NameEl.textContent = player1.username || "Player 1";
        player2NameEl.textContent = player2.username || "Player 2";

        // Determine which player is current user, load their deck
        if (currentUser.uid === uid1) {
          playerDeck = Array.isArray(player1.deck) ? [...player1.deck] : [];
          playerSide = "player1";
        } else if (currentUser.uid === uid2) {
          playerDeck = Array.isArray(player2.deck) ? [...player2.deck] : [];
          playerSide = "player2";
        } else {
          alert("You are not in this battle.");
          window.location.href = "home.html";
          return;
        }

        await loadCardData();

        renderHand();
        renderTowers();

        startText.textContent = "✅ Battle Ready! Select a card and place it on your side.";

      } catch (err) {
        console.error(err);
        startText.textContent = "❌ Error loading battle.";
      }
    }

    // Render hand cards visually
    function renderHand() {
      hand.innerHTML = '';
      playerDeck.forEach((cardId, idx) => {
        const cardData = cardDataCache[cardId];
        if (!cardData) return;
        const cardEl = document.createElement('div');
        cardEl.classList.add('card');
        cardEl.textContent = cardData.name || cardId;
        cardEl.title = `${cardData.name}\nHP: ${cardData.hitpoints}\nDamage: ${cardData.damage}\nTargets: ${cardData.targets.join(", ")}`;
        cardEl.dataset.idx = idx;
        cardEl.addEventListener('click', () => {
          if (selectedCardIndex === idx) {
            selectedCardIndex = null;
            selectedCardData = null;
          } else {
            selectedCardIndex = idx;
            selectedCardData = cardData;
          }
          updateHandSelection();
        });
        hand.appendChild(cardEl);
      });
      updateHandSelection();
    }

    function updateHandSelection() {
      const cards = hand.querySelectorAll('.card');
      cards.forEach((c, i) => {
        c.classList.toggle('selected', i === selectedCardIndex);
      });
    }

    // Render towers visually on map with HP bars
    function renderTowers() {
      // Remove old tower DOMs
      document.querySelectorAll('.tower').forEach(t => t.remove());
      [...towers.player1, ...towers.player2].forEach(tower => {
        const towerEl = document.createElement('div');
        towerEl.classList.add('tower');
        towerEl.style.position = 'absolute';
        towerEl.style.left = `${tower.x}px`;
        towerEl.style.top = `${tower.y}px`;
        towerEl.style.width = '80px';
        towerEl.style.height = '100px';
        towerEl.style.backgroundColor = tower.owner === "player1" ? "#880000cc" : "#004488cc";
        towerEl.style.border = tower.owner === "player1" ? "2px solid #cc0000" : "2px solid #0077cc";
        towerEl.style.borderRadius = '12px';
        towerEl.style.color = '#fff';
        towerEl.style.fontWeight = 'bold';
        towerEl.style.display = 'flex';
        towerEl.style.justifyContent = 'center';
        towerEl.style.alignItems = 'center';
        towerEl.textContent = "Tower";

        // HP bar
        const hpBarContainer = document.createElement('div');
        hpBarContainer.className = 'hp-bar-container';
        hpBarContainer.style.top = '5px';
        hpBarContainer.style.position = 'absolute';
        hpBarContainer.style.left = '50%';
        hpBarContainer.style.transform = 'translateX(-50%)';
        hpBarContainer.style.width = '70%';
        hpBarContainer.style.height = '8px';
        hpBarContainer.style.background = '#333';
        hpBarContainer.style.borderRadius = '4px';

        const hpBar = document.createElement('div');
        hpBar.className = 'hp-bar';
        hpBar.style.width = '100%';
        hpBar.style.height = '100%';
        hpBar.style.backgroundColor = '#0f0';
        hpBar.style.borderRadius = '4px';

        hpBarContainer.appendChild(hpBar);
        towerEl.appendChild(hpBarContainer);

        map.appendChild(towerEl);

        tower.domElement = towerEl;
        tower.hpBarElement = hpBar;
      });
    }

    // Place card on map visually and add to placedCards with full data
    function placeCardOnMap(cardId, x, y) {
      const cardData = cardDataCache[cardId];
      if (!cardData) return;

      const cardEl = document.createElement('div');
      cardEl.classList.add('placed-card');
      cardEl.textContent = cardData.name || cardId;
      cardEl.style.left = `${x - 30}px`;
      cardEl.style.top = `${y - 40}px`;

      // HP bar container
      const hpBarContainer = document.createElement('div');
      hpBarContainer.className = 'hp-bar-container';
      hpBarContainer.style.top = '5px';
      hpBarContainer.style.position = 'absolute';
      hpBarContainer.style.left = '50%';
      hpBarContainer.style.transform = 'translateX(-50%)';
      hpBarContainer.style.width = '70%';
      hpBarContainer.style.height = '8px';
      hpBarContainer.style.background = '#333';
      hpBarContainer.style.borderRadius = '4px';

      const hpBar = document.createElement('div');
      hpBar.className = 'hp-bar';
      hpBar.style.width = '100%';
      hpBar.style.height = '100%';
      hpBar.style.backgroundColor = '#0f0';
      hpBar.style.borderRadius = '4px';

      hpBarContainer.appendChild(hpBar);
      cardEl.appendChild(hpBarContainer);

      map.appendChild(cardEl);

      // Add to placed cards array
      placedCards.push({
  id: cardId,
  owner: playerSide,
  x,
  y,
  hp: cardData.hitpoints,
  maxHp: cardData.hitpoints,
  damage: cardData.damage,
  targets: cardData.targets,
  speed: parseSpeed(cardData.speed),
  range: parseRange(cardData.range),
  hitspeed: cardData.hitspeed || 1.0,
  attackCooldown: 0,
  domElement: cardEl,
  hpBarElement: hpBar
});

      // Remove from playerDeck and re-render hand
      playerDeck.splice(selectedCardIndex, 1);
      selectedCardIndex = null;
      selectedCardData = null;
      renderHand();
      startText.textContent = "Card placed! Select another card or wait for battle.";
    }

    // Find target for a card to attack
    function findTarget(card) {
      const enemySide = card.owner === 'player1' ? 'player2' : 'player1';

      // Priority 1: Enemy cards matching card.targets
      const enemyCards = placedCards.filter(c =>
        c.owner === enemySide &&
        c.hp > 0 &&
        c.targets.some(t => card.targets.includes(t))
      );

      if (enemyCards.length > 0) {
        enemyCards.sort((a, b) => {
          const distA = distance(card.x, card.y, a.x, a.y);
          const distB = distance(card.x, card.y, b.x, b.y);
          return distA - distB;
        });
        return enemyCards[0];
      }

      // Priority 2: Enemy towers (target "buildings")
      if (card.targets.includes('buildings')) {
        const enemyTowers = towers[enemySide].filter(t => t.hp > 0);
        if (enemyTowers.length > 0) {
          enemyTowers.sort((a, b) => {
            const distA = distance(card.x, card.y, a.x, a.y);
            const distB = distance(card.x, card.y, b.x, b.y);
            return distA - distB;
          });
          return enemyTowers[0];
        }
      }

      // No target found
      return null;
    }

    // Calculate Euclidean distance
    function distance(x1, y1, x2, y2) {
      return Math.hypot(x2 - x1, y2 - y1);
    }

    // Apply damage to target (card or tower)
    function applyDamage(target, damage) {
      target.hp -= damage;
      if (target.hp < 0) target.hp = 0;

      // Update HP bar width and color
      const hpPercent = target.hp / target.maxHp;
      if (target.hpBarElement) {
        target.hpBarElement.style.width = (hpPercent * 100) + '%';
        if (hpPercent > 0.5) {
          target.hpBarElement.style.backgroundColor = '#0f0';
        } else if (hpPercent > 0.2) {
          target.hpBarElement.style.backgroundColor = '#ff0';
        } else {
          target.hpBarElement.style.backgroundColor = '#f00';
        }
      }

      // Remove card if dead
      if (target.hp <= 0) {
        if (target.domElement) {
          target.domElement.remove();
        }
        if (placedCards.includes(target)) {
          placedCards = placedCards.filter(c => c !== target);
        }
        // TODO: Check for game end condition if tower destroyed
      }
    }

// At the bottom of your script:

let lastUpdateTime = performance.now();

function gameLoop() {
  const now = performance.now();
  const deltaTime = (now - lastUpdateTime) / 1000;
  lastUpdateTime = now;

  placedCards.forEach(card => {
    if (card.hp <= 0) return;

    card.attackCooldown -= deltaTime;
    if (card.attackCooldown < 0) card.attackCooldown = 0;

    const target = findTarget(card);
    if (!target) return;

    const dist = distance(card.x, card.y, target.x, target.y);

    if (dist > card.range) {
      const dx = target.x - card.x;
      const dy = target.y - card.y;
      const angle = Math.atan2(dy, dx);

      const moveDist = Math.min(card.speed * deltaTime, dist - card.range);
      card.x += Math.cos(angle) * moveDist;
      card.y += Math.sin(angle) * moveDist;

      if (card.domElement) {
        card.domElement.style.left = `${card.x - 30}px`;
        card.domElement.style.top = `${card.y - 40}px`;
      }
    } else {
      if (card.attackCooldown === 0) {
        applyDamage(target, card.damage);
        card.attackCooldown = card.hitspeed;

        startText.textContent = `${card.id} attacks ${target.id} for ${card.damage} damage!`;
      }
    }
  });

  requestAnimationFrame(gameLoop);
}

// Replace aiAttackLoop() with this:
auth.onAuthStateChanged((user) => {
  if (!user) {
    window.location.href = "index.html";
    return;
  }
  currentUser = user;
  loadBattle().then(() => {
    gameLoop(); // ✅ Start real-time game loop
  });
});
  </script>
</body>
</html>
