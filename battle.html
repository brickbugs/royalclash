<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Clash Royale Clone - Battle</title>
<style>
  body, html {
    margin: 0; padding: 0; height: 100%; background: #181818; color: white; font-family: Arial, sans-serif;
    user-select: none;
    overflow: hidden;
  }
  #battleArea {
    position: relative;
    width: 100vw;
    height: 100vh;
    display: flex;
    flex-direction: column;
  }
  #map {
    flex-grow: 1;
    background: linear-gradient(to top, #0b5700 0%, #147b00 100%);
    position: relative;
    cursor: crosshair;
  }
  #map::before {
    content: "";
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    height: 3px;
    background: rgba(255, 255, 255, 0.2);
  }
  #hand {
    height: 140px;
    background: #222;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px;
    gap: 15px;
    box-shadow: 0 -5px 15px rgba(0,0,0,0.7);
  }
  .card {
    background: #444;
    border-radius: 12px;
    width: 80px;
    height: 110px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 24px;
    font-weight: bold;
    color: white;
    box-shadow: 0 3px 6px rgba(0,0,0,0.8);
    user-select: none;
    transition: transform 0.2s ease;
    cursor: pointer;
    position: relative;
  }
  .card.selected {
    outline: 3px solid #4caf50;
    transform: scale(1.1);
  }
  /* Placed cards on map */
  .placed-card {
    position: absolute;
    width: 60px;
    height: 80px;
    background: #4caf50cc;
    border-radius: 10px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    color: #fff;
    pointer-events: none;
    user-select: none;
  }
  .hp-bar-container {
    position: absolute;
    top: 5px;
    left: 50%;
    transform: translateX(-50%);
    width: 70%;
    height: 8px;
    background: #333;
    border-radius: 4px;
  }
  .hp-bar {
    height: 100%;
    background: #0f0;
    border-radius: 4px;
    width: 100%;
  }
  #startText {
    position: absolute;
    top: 10px;
    width: 100%;
    text-align: center;
    font-size: 22px;
    color: #0f0;
    pointer-events: none;
    user-select: none;
    z-index: 100;
  }
  /* Player names at top of map */
  #playerNames {
    position: absolute;
    top: 10px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    padding: 0 30px;
    font-size: 18px;
    color: white;
    pointer-events: none;
    user-select: none;
    z-index: 100;
  }
</style>
</head>
<body>
  <div id="startText"></div>
<div id="playerNames" style="display:flex; justify-content:space-between; width:800px; margin: 0 auto; color:white; font-weight:bold; font-size:18px; padding: 5px 10px;">
  <div id="player1Name">Player 1</div>
  <div id="player2Name">Player 2</div>
</div>
<div id="hand" style="display:flex; gap:10px; justify-content:center; margin: 10px auto; width:800px;"></div>
<div id="map" style="position:relative; width:800px; height:400px; border:1px solid #000; margin: 0 auto;"></div>


  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>

 <script>
// Firebase config and initialization
const firebaseConfig = {
  apiKey: "AIzaSyADqsChcYfhT_bAlQ1VWkrlga-oTJViz7U",
  authDomain: "clashroyaleclone-ae764.firebaseapp.com",
  projectId: "clashroyaleclone-ae764",
  storageBucket: "clashroyaleclone-ae764.appspot.com",
  messagingSenderId: "938364278081",
  appId: "1:938364278081:web:1c214bd66caef6d7567dc0",
  measurementId: "G-PT2GPP0JF5"
};

firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();

const hand = document.getElementById("hand");
const map = document.getElementById("map");
const startText = document.getElementById("startText");
const player1NameEl = document.getElementById("player1Name");
const player2NameEl = document.getElementById("player2Name");

let currentUser = null;
let playerSide = null;     // "player1" or "player2"
let enemySide = null;
let playerDeck = [];
let enemyDeck = [];
let selectedCardIndex = null;
let selectedCardData = null;

let placedCards = [];
let cardDataCache = {};    // cardId -> data cache

const lobbyId = localStorage.getItem("lobbyId");
if (!lobbyId) {
  alert("Lobby ID not found! Redirecting to home.");
  window.location.href = "home.html";
  throw new Error("No lobbyId found, stopping script.");
}

// Load card data from Firestore "cards" collection
async function loadCardData() {
  const cardsSnapshot = await db.collection("cards").get();
  cardsSnapshot.forEach(doc => {
    const id = doc.id.toLowerCase();
    const data = doc.data();
    cardDataCache[id] = {
      name: data.name || doc.id,
      hitpoints: data.hitpoints || 100,
      damage: data.damage || 10,
      targets: (data.targets || "ground").split(",").map(t => t.trim()),
      elixir: data.elixir || 1,
      bio: data.bio || "",
      count: data.count || 1,
      speed: data.speed || "medium",
      range: data.range || "melee",
      hitspeed: data.hitspeed || 1.0
    };
  });
  console.log("Card data loaded:", Object.keys(cardDataCache));
}

// Load battle info and decks, set sides
async function loadBattle() {
  startText.textContent = "Loading battle data...";

  try {
    const lobbySnap = await db.collection("lobbies").doc(lobbyId).get();
    const lobbyData = lobbySnap.data();

    if (!lobbyData || !Array.isArray(lobbyData.players) || lobbyData.players.length < 2) {
      startText.textContent = "❌ Waiting for opponent...";
      return;
    }

    const [uid1, uid2] = lobbyData.players;

    const [player1Snap, player2Snap] = await Promise.all([
      db.collection("players").doc(uid1).get(),
      db.collection("players").doc(uid2).get(),
    ]);

    const player1 = player1Snap.data();
    const player2 = player2Snap.data();

    player1NameEl.textContent = player1?.username || "Player 1";
    player2NameEl.textContent = player2?.username || "Player 2";

    if (currentUser.uid === uid1) {
      playerSide = "player1";
      enemySide = "player2";
      playerDeck = Array.isArray(player1?.deck) ? [...player1.deck] : [];
      enemyDeck = Array.isArray(player2?.deck) ? [...player2.deck] : [];
    } else if (currentUser.uid === uid2) {
      playerSide = "player2";
      enemySide = "player1";
      playerDeck = Array.isArray(player2?.deck) ? [...player2.deck] : [];
      enemyDeck = Array.isArray(player1?.deck) ? [...player1.deck] : [];
    } else {
      alert("You are not in this battle.");
      window.location.href = "home.html";
      return;
    }

    await loadCardData();

    renderHand(playerDeck);

    startText.textContent = "✅ Battle Ready! Select a card and place it on your side.";

  } catch (err) {
    console.error(err);
    startText.textContent = "❌ Error loading battle.";
  }
}

function renderHand(deck) {
  hand.innerHTML = '';
  deck.forEach((cardId, idx) => {
    if (!cardId) {
      console.warn(Skipping invalid cardId at index ${idx}:, cardId);
      return;
    }
    const cardIdNormalized = cardId.toLowerCase();
    const cardData = cardDataCache[cardIdNormalized];
    if (!cardData) {
      console.warn(Card data missing for cardId: ${cardId});
      return;
    }
    const cardEl = document.createElement('div');
    cardEl.classList.add('card');
    cardEl.textContent = cardData.name || cardId;
    cardEl.title = ${cardData.name}\nHP: ${cardData.hitpoints}\nDamage: ${cardData.damage}\nTargets: ${cardData.targets.join(", ")};
    cardEl.dataset.idx = idx;
    cardEl.addEventListener('click', () => {
      if (selectedCardIndex === idx) {
        selectedCardIndex = null;
        selectedCardData = null;
      } else {
        selectedCardIndex = idx;
        selectedCardData = cardData;
      }
      updateHandSelection();
    });
    hand.appendChild(cardEl);
  });
  updateHandSelection();
}

function updateHandSelection() {
  const cards = hand.querySelectorAll(".card");
  cards.forEach((cardEl, i) => {
    cardEl.classList.toggle("selected", i === selectedCardIndex);
  });
}

function startPlacementListener() {
  const cardMap = new Map();

  db.collection("lobbies")
    .doc(lobbyId)
    .collection("placements")
    .orderBy("createdAt")
    .onSnapshot(snapshot => {
      snapshot.docChanges().forEach(change => {
        const doc = change.doc;
        const data = doc.data();
        const id = doc.id;

        if (change.type === "added") {
          if (!cardMap.has(id)) {
            const card = renderPlacedCard(id, data);
            cardMap.set(id, card);
          }
        } else if (change.type === "modified") {
          const card = cardMap.get(id);
          if (card) {
            card.targetX = data.x;
            card.targetY = data.y;
            card.hp = data.hp;

            // Update HP bar
            const hpPercent = (card.hp / card.maxHp) * 100;
            card.hpBarElement.style.width = ${hpPercent}%;
            card.hpBarElement.style.backgroundColor = hpPercent < 30 ? "#f00" : "#0f0";

            if (card.hp <= 0) {
              card.domElement.style.opacity = "0.5";

              // Delete dead card from Firestore once
              db.collection("lobbies")
                .doc(lobbyId)
                .collection("placements")
                .doc(id)
                .delete()
                .catch(err => console.error("Error deleting dead card:", err));
            }
          }
        } else if (change.type === "removed") {
          const card = cardMap.get(id);
          if (card && card.domElement && card.domElement.parentElement) {
            card.domElement.remove();
          }
          cardMap.delete(id);
          placedCards = placedCards.filter(p => p.id !== id);
        }
      });
    });
}

function renderPlacedCard(id, data) {
  if (!data.cardId || !cardDataCache[data.cardId.toLowerCase()]) {
    console.warn("Invalid cardId or missing card data for placed card", data.cardId);
    return null;
  }

  const cardIdNormalized = data.cardId.toLowerCase();
  const cardData = cardDataCache[cardIdNormalized];

  const cardEl = document.createElement("div");
  cardEl.className = "placed-card";
  cardEl.textContent = cardData.name || data.cardId;
  cardEl.style.position = "absolute";
  cardEl.style.left = ${data.x - 30}px;
  cardEl.style.top = ${data.y - 40}px;
  cardEl.style.zIndex = data.owner === playerSide ? 10 : 5;
  cardEl.style.background = data.owner === "player1" ? "#2196f3cc" : "#e91e63cc"; // Blue for player1, pink for player2
  cardEl.style.border = "2px solid white";

  const hpBarContainer = document.createElement("div");
  hpBarContainer.className = "hp-bar-container";

  const hpBar = document.createElement("div");
  hpBar.className = "hp-bar";

  const hpPercent = (data.hp / data.maxHp) * 100;
  hpBar.style.width = ${hpPercent}%;
  hpBar.style.backgroundColor = hpPercent < 30 ? "#f00" : "#0f0";

  if (data.hp <= 0) {
    cardEl.style.opacity = "0.5";
  }

  hpBarContainer.appendChild(hpBar);
  cardEl.appendChild(hpBarContainer);
  map.appendChild(cardEl);

  const cardObj = {
    id,
    owner: data.owner,
    x: data.x,
    y: data.y,
    hp: data.hp,
    maxHp: data.maxHp,
    damage: data.damage,
    targets: data.targets,
    speed: parseSpeed(data.speed),
    range: parseRange(data.range),
    hitspeed: data.hitspeed,
    attackCooldown: 0,
    domElement: cardEl,
    hpBarElement: hpBar,
    targetX: data.x,
    targetY: data.y,
  };

  placedCards.push(cardObj);
  return cardObj;
}

function parseSpeed(speedStr) {
  switch ((speedStr || "").toLowerCase()) {
    case "slow": return 30;
    case "medium": return 60;
    case "fast": return 120;
    default:
      let n = parseFloat(speedStr);
      return isNaN(n) ? 60 : n;
  }
}

function parseRange(rangeStr) {
  switch ((rangeStr || "").toLowerCase()) {
    case "melee": return 40;
    case "short": return 80;
    case "medium": return 150;
    case "long": return 250;
    default:
      let n = parseFloat(rangeStr);
      return isNaN(n) ? 50 : n;
  }
}

map.addEventListener("click", async (e) => {
  if (selectedCardIndex === null || !selectedCardData) {
    startText.textContent = "Select a card first!";
    return;
  }

  const rect = map.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  if ((playerSide === "player1" && clickY > rect.height / 2) ||
      (playerSide === "player2" && clickY < rect.height / 2)) {
    startText.textContent = "Place cards only on your side!";
    return;
  }

  const cardId = playerDeck[selectedCardIndex];
  const cardData = cardDataCache[cardId.toLowerCase()];

  if (!cardData) {
    startText.textContent = "Card data missing, cannot place.";
    return;
  }

  try {
    await db.collection("lobbies")
      .doc(lobbyId)
      .collection("placements")
      .add({
        cardId: cardId,
        owner: playerSide,
        x: clickX,
        y: clickY,
        hp: cardData.hitpoints,
        maxHp: cardData.hitpoints,
        damage: cardData.damage,
        targets: cardData.targets,
        speed: cardData.speed,
        range: cardData.range,
        hitspeed: cardData.hitspeed || 1.0,
        createdAt: firebase.firestore.FieldValue.serverTimestamp()
      });

    startText.textContent = "Card placed!";

    playerDeck.splice(selectedCardIndex, 1);
    renderHand(playerDeck);
    selectedCardIndex = null;
    selectedCardData = null;

  } catch (err) {
    console.error("Error placing card:", err);
    startText.textContent = "Failed to place card.";
  }
});

function distance(x1, y1, x2, y2) {
  return Math.hypot(x2 - x1, y2 - y1);
}
   
let lastUpdateTime = performance.now();

function gameLoop() {
  const now = performance.now();
  const deltaTime = (now - lastUpdateTime) / 1000;
  lastUpdateTime = now;

  const lerpFactor = 0.15;

  placedCards.forEach(card => {
    if (!card || typeof card.hp !== 'number' || card.hp <= 0) return;

    // Smooth interpolation toward Firestore position
    card.x += (card.targetX - card.x) * lerpFactor;
    card.y += (card.targetY - card.y) * lerpFactor;

    if (card.domElement) {
      card.domElement.style.left = ${card.x - 30}px;
      card.domElement.style.top = ${card.y - 40}px;
    }

    if (card.owner !== playerSide) return; // Only control your own cards

    card.attackCooldown = Math.max(0, card.attackCooldown - deltaTime);

    // Find target in range
    const target = placedCards.find(c =>
      c &&
      c.owner !== card.owner &&
      c.hp > 0 &&
      distance(card.x, card.y, c.x, c.y) <= card.range
    );

    if (!target) {
      // Move toward nearest enemy
      const nearestEnemy = placedCards.find(c => c && c.owner !== card.owner && c.hp > 0);
      if (nearestEnemy) {
        const dx = nearestEnemy.x - card.x;
        const dy = nearestEnemy.y - card.y;
        const dist = Math.hypot(dx, dy);

        if (dist > card.range) {
          const angle = Math.atan2(dy, dx);
          const moveDist = Math.min(card.speed * deltaTime, dist - card.range);
          card.x += Math.cos(angle) * moveDist;
          card.y += Math.sin(angle) * moveDist;

          card.targetX = card.x;
          card.targetY = card.y;

         if (card.id && typeof card.id === "string") {
  db.collection("lobbies")
    .doc(lobbyId)
    .collection("placements")
    .doc(card.id)
    .update({
      x: card.x,
      y: card.y,
    }).catch(err => console.error("Movement update failed:", err));
} else {
  console.warn("Skipping movement update: invalid card.id", card);
}

        }
      }
      return;
    }

    // Attack
    if (card.attackCooldown <= 0) {
      const newHp = Math.max(0, target.hp - card.damage);
      card.attackCooldown = card.hitspeed;

      db.collection("lobbies")
        .doc(lobbyId)
        .collection("placements")
        .doc(target.id)
        .update({ hp: newHp })
        .catch(err => console.error("Error updating HP:", err));

      console.log(${card.id} attacks ${target.id} for ${card.damage} damage);
    }
  });

  requestAnimationFrame(gameLoop);
}


auth.onAuthStateChanged(async (user) => {
  if (!user) {
    window.location.href = "index.html";
    return;
  }
  currentUser = user;
  await loadBattle();
  startPlacementListener();
  gameLoop();
});

</script>
</body>
</html> 
