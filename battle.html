<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Clash Royale Clone - Battle</title>
<style>
  body, html {
    margin: 0; padding: 0; height: 100%; background: #181818; color: white; font-family: Arial, sans-serif;
    user-select: none;
    overflow: hidden;
  }
  #battleArea {
    position: relative;
    width: 100vw;
    height: 100vh;
    display: flex;
    flex-direction: column;
  }
  #map {
    flex-grow: 1;
    background: linear-gradient(to top, #0b5700 0%, #147b00 100%);
    position: relative;
    cursor: crosshair;
  }
  #map::before {
    content: "";
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    height: 3px;
    background: rgba(255, 255, 255, 0.2);
  }
  #hand {
    height: 140px;
    background: #222;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px;
    gap: 15px;
    box-shadow: 0 -5px 15px rgba(0,0,0,0.7);
  }
  .card {
    background: #444;
    border-radius: 12px;
    width: 80px;
    height: 110px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 24px;
    font-weight: bold;
    color: white;
    box-shadow: 0 3px 6px rgba(0,0,0,0.8);
    user-select: none;
    transition: transform 0.2s ease;
    cursor: pointer;
    position: relative;
  }
  .card.selected {
    outline: 3px solid #4caf50;
    transform: scale(1.1);
  }
  /* Placed cards on map */
  .placed-card {
    position: absolute;
    width: 60px;
    height: 80px;
    background: #4caf50cc;
    border-radius: 10px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    color: #fff;
    pointer-events: none;
    user-select: none;
  }
  .hp-bar-container {
    position: absolute;
    top: 5px;
    left: 50%;
    transform: translateX(-50%);
    width: 70%;
    height: 8px;
    background: #333;
    border-radius: 4px;
  }
  .hp-bar {
    height: 100%;
    background: #0f0;
    border-radius: 4px;
    width: 100%;
  }
  #startText {
    position: absolute;
    top: 10px;
    width: 100%;
    text-align: center;
    font-size: 22px;
    color: #0f0;
    pointer-events: none;
    user-select: none;
    z-index: 100;
  }
  /* Player names at top of map */
  #playerNames {
    position: absolute;
    top: 10px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    padding: 0 30px;
    font-size: 18px;
    color: white;
    pointer-events: none;
    user-select: none;
    z-index: 100;
  }
</style>
</head>
<body>
  <div id="startText"></div>
<div id="playerNames" style="display:flex; justify-content:space-between; width:800px; margin: 0 auto; color:white; font-weight:bold; font-size:18px; padding: 5px 10px;">
  <div id="player1Name">Player 1</div>
  <div id="player2Name">Player 2</div>
</div>
<div id="hand" style="display:flex; gap:10px; justify-content:center; margin: 10px auto; width:800px;"></div>
<div id="elixirBarContainer" style="width: 800px; height: 20px; background: #333; margin: 10px auto; border-radius: 10px; overflow: hidden;">
  <div id="elixirBar" style="height: 100%; width: 100%; background: #7be3ff; transition: width 0.2s;"></div>
</div>
<div id="map" style="position:relative; width:800px; height:400px; border:1px solid #000; margin: 0 auto;"></div>


<!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-database-compat.js"></script>

<script>
const firebaseConfig = {
  apiKey: "AIzaSyADqsChcYfhT_bAlQ1VWkrlga-oTJViz7U",
  authDomain: "clashroyaleclone-ae764.firebaseapp.com",
  projectId: "clashroyaleclone-ae764",
  storageBucket: "clashroyaleclone-ae764.appspot.com",
  messagingSenderId: "938364278081",
  appId: "1:938364278081:web:1c214bd66caef6d7567dc0",
  measurementId: "G-PT2GPP0JF5",
  databaseURL: "https://clashroyaleclone-ae764-default-rtdb.firebaseio.com"
};
firebase.initializeApp(firebaseConfig);

const auth = firebase.auth();
const db = firebase.firestore();
const rtdb = firebase.database();

const hand = document.getElementById("hand");
const map = document.getElementById("map");
const startText = document.getElementById("startText");
const player1NameEl = document.getElementById("player1Name");
const player2NameEl = document.getElementById("player2Name");
const elixirBar = document.getElementById("elixirBar");

let currentUser, playerSide, enemySide,
    playerDeck = [], enemyDeck = [],
    selectedCardIndex = null, selectedCardData = null,
    elixir = 10, maxElixir = 10,
    placedCards = [], cardDataCache = {};
const lastSync = new Map();

function shouldSync(id, delay = 300) {
  const now = Date.now();
  if (!lastSync.has(id) || now - lastSync.get(id) > delay) {
    lastSync.set(id, now);
    return true;
  }
  return false;
}

function updateElixirBar() {
  elixirBar.style.width = `${(elixir / maxElixir) * 100}%`;
}
setInterval(() => {
  if (elixir < maxElixir) {
    elixir = Math.min(maxElixir, elixir + 1);
    updateElixirBar();
  }
}, 1000);

const matchId = localStorage.getItem("matchId");
const matchCreator = localStorage.getItem("matchCreator");

if (!matchId || !matchCreator) {
  alert("Missing match info!");
  window.location.href = "home.html";
  throw new Error("MatchId or Creator missing");
}

async function loadCardData() {
  try {
    const snap = await db.collection("cards").get();
    snap.forEach(doc => {
      cardDataCache[doc.id.toLowerCase()] = doc.data();
    });
  } catch (err) {
    console.error("Failed to load card data:", err);
  }
}

async function loadBattle() {
  console.log("Loading battle. currentUser:", currentUser?.uid);
  startText.textContent = "Loading battle data...";

  try {
    const lobbyRef = db.collection("lobbies")
      .doc(matchCreator)
      .collection("matches")
      .doc(matchId);
    const lobbySnap = await lobbyRef.get();

    console.log("Lobby snapshot:", lobbySnap.exists, lobbySnap.data());

    if (!lobbySnap.exists) {
      startText.textContent = "❌ Lobby not found!";
      return;
    }

    const players = lobbySnap.data().players || [];
    console.log("Players in lobby:", players);
    if (players.length < 2) {
      startText.textContent = "❌ Waiting for opponent...";
      return;
    }

    const [uid1, uid2] = players;
    const snaps = await Promise.all([
      db.collection("players").doc(uid1).get(),
      db.collection("players").doc(uid2).get()
    ]);
    const d1 = snaps[0].data(), d2 = snaps[1].data();

    player1NameEl.textContent = d1?.username || "Player 1";
    player2NameEl.textContent = d2?.username || "Player 2";

    if (currentUser.uid === uid1) {
      playerSide = "player1"; enemySide = "player2";
      playerDeck = [...(d1.deck || [])]; enemyDeck = [...(d2.deck || [])];
    } else if (currentUser.uid === uid2) {
      playerSide = "player2"; enemySide = "player1";
      playerDeck = [...(d2.deck || [])]; enemyDeck = [...(d1.deck || [])];
    } else {
      alert("Not in this match.");
      window.location.href = "home.html";
      return;
    }

    await loadCardData();
    renderHand(playerDeck);
    startText.textContent = "✅ Battle ready! Select & place a card.";
  } catch (err) {
    console.error("Error loading battle:", err);
    startText.textContent = "❌ Error loading battle.";
  }
}

function renderHand(deck) {
  hand.innerHTML = "";
  deck.forEach((cid, idx) => {
    const cd = cardDataCache[cid.toLowerCase()];
    if (!cd) return;
    const el = document.createElement("div");
    el.classList.add("card");
    el.innerHTML = `${cd.name}<br><span style="font-size:14px; color:#7be3ff;">${cd.elixir}⚡</span>`;
    el.title = `${cd.name}\nHP:${cd.hitpoints} DMG:${cd.damage}\nTargets:${cd.targets}`;
    el.dataset.idx = idx;
    el.onclick = () => {
      selectedCardIndex = selectedCardIndex === idx ? null : idx;
      selectedCardData = selectedCardIndex === null ? null : cd;
      updateHandSelection();
    };
    hand.appendChild(el);
  });
  updateHandSelection();
}

function updateHandSelection() {
  hand.querySelectorAll(".card").forEach((el, i) => el.classList.toggle("selected", i === selectedCardIndex));
}

function parseSpeed(s) {
  return s === "fast" ? 120 : s === "slow" ? 30 : 60;
}
function parseRange(r) {
  return r === "long" ? 250 : r === "short" ? 80 : r === "melee" ? 40 : 150;
}
function distance(x1, y1, x2, y2) {
  return Math.hypot(x2 - x1, y2 - y1);
}

function startPlacementListener() {
  const ref = rtdb.ref(`battles/${matchCreator}/${matchId}/placements`);
  ref.on("child_added", snap => {
    if (!placedCards.some(p => p.id === snap.key)) renderPlacedCard(snap.key, snap.val());
  });
  ref.on("child_changed", snap => {
    const c = placedCards.find(p => p.id === snap.key);
    if (c) {
      const d = snap.val();
      c.targetX = d.x; c.targetY = d.y; c.hp = d.hp;
      const pct = (c.hp / c.maxHp) * 100;
      c.hpBarElement.style.width = `${pct}%`;
      c.hpBarElement.style.backgroundColor = pct < 30 ? "#f00" : "#0f0";
      if (c.hp <= 0) c.domElement.style.opacity = "0.5";
    }
  });
  ref.on("child_removed", snap => {
    const idx = placedCards.findIndex(p => p.id === snap.key);
    if (idx >= 0) {
      placedCards[idx].domElement.remove();
      placedCards.splice(idx, 1);
    }
  });
}

function renderPlacedCard(id, data) {
  const cd = cardDataCache[data.cardId.toLowerCase()];
  if (!cd) return null;
  const el = document.createElement("div");
  el.className = "placed-card";
  el.textContent = cd.name;
  el.style.left = `${data.x - 30}px`;
  el.style.top = `${data.y - 40}px`;
  el.style.zIndex = data.owner === playerSide ? 10 : 5;
  el.style.background = data.owner === "player1" ? "#2196f3cc" : "#e91e63cc";
  const hpContainer = document.createElement("div");
  hpContainer.className = "hp-bar-container";
  const hpBar = document.createElement("div");
  hpBar.className = "hp-bar";
  hpContainer.appendChild(hpBar);
  el.appendChild(hpContainer);
  map.appendChild(el);
  const pct = (data.hp / data.maxHp) * 100;
  hpBar.style.width = `${pct}%`;
  hpBar.style.backgroundColor = pct < 30 ? "#f00" : "#0f0";

  const obj = {
    id,
    owner: data.owner,
    x: data.x,
    y: data.y,
    hp: data.hp,
    maxHp: data.maxHp,
    damage: data.damage,
    targets: data.targets,
    speed: parseSpeed(data.speed),
    range: parseRange(data.range),
    hitspeed: data.hitspeed,
    attackCooldown: 0,
    skill: cd.skill,
    skillCooldownTime: cd.skillCooldownTime,
    skillCooldownTracker: 0,
    domElement: el,
    hpBarElement: hpBar,
    targetX: data.x,
    targetY: data.y
  };
  placedCards.push(obj);
  return obj;
}

map.addEventListener("click", async e => {
  if (selectedCardIndex === null || !selectedCardData) {
    startText.textContent = "Select a card first!";
    return;
  }
  const rect = map.getBoundingClientRect();
  const x = e.clientX - rect.left, y = e.clientY - rect.top;
  if ((playerSide === "player1" && y > rect.height / 2) || (playerSide === "player2" && y < rect.height / 2)) {
    startText.textContent = "Place cards only on your side!";
    return;
  }
  const cid = playerDeck[selectedCardIndex], cd = cardDataCache[cid.toLowerCase()];
  if (elixir < cd.elixir) {
    startText.textContent = `❌ Not enough elixir! (${cd.elixir} needed)`;
    return;
  }

  try {
    const newRef = rtdb.ref(`battles/${matchCreator}/${matchId}/placements`).push();
    await newRef.set({
      cardId: cid,
      owner: playerSide,
      x, y,
      hp: cd.hitpoints,
      maxHp: cd.hitpoints,
      damage: cd.damage,
      targets: cd.targets,
      speed: cd.speed,
      range: cd.range,
      hitspeed: cd.hitspeed
    });
    startText.textContent = "Card placed!";
    playerDeck.splice(selectedCardIndex, 1);
    renderHand(playerDeck);
    selectedCardIndex = selectedCardData = null;
    elixir -= cd.elixir;
    updateElixirBar();
  } catch (err) {
    console.error("Place error:", err);
    startText.textContent = "Failed to place card.";
  }
});

let last = performance.now();
function gameLoop() {
  const now = performance.now(), dt = (now - last) / 1000;
  last = now;

  placedCards.forEach(card => {
    if (!card || card.hp <= 0) return;
    card.x += (card.targetX - card.x) * 0.15;
    card.y += (card.targetY - card.y) * 0.15;
    card.domElement.style.left = `${card.x - 30}px`;
    card.domElement.style.top = `${card.y - 40}px`;

    if (card.owner !== playerSide) return;
    card.attackCooldown = Math.max(0, card.attackCooldown - dt);

    if (card.skill) {
      card.skillCooldownTracker = Math.max(0, card.skillCooldownTracker - dt);
      if (card.skillCooldownTracker <= 0) {
        Skills?.[card.skill]?.(card, placedCards, rtdb, matchCreator, matchId);
        card.skillCooldownTracker = card.skillCooldownTime;
      }
    }

    const target = placedCards.find(c => c.owner !== card.owner && c.hp > 0 &&
      distance(card.x, card.y, c.x, c.y) <= card.range);

    if (!target) {
      const nearest = placedCards.find(c => c.owner !== card.owner && c.hp > 0);
      if (nearest) {
        const dx = nearest.x - card.x, dy = nearest.y - card.y;
        const dist = Math.hypot(dx, dy);
        if (dist > card.range) {
          const angle = Math.atan2(dy, dx);
          const moveDist = Math.min(card.speed * dt, dist - card.range);
          card.x += Math.cos(angle) * moveDist;
          card.y += Math.sin(angle) * moveDist;
          card.targetX = card.x; card.targetY = card.y;
          if (card.id && shouldSync(card.id)) {
            rtdb.ref(`battles/${matchCreator}/${matchId}/placements/${card.id}`)
              .update({ x: card.x, y: card.y }).catch(console.error);
          }
        }
      }
      return;
    }

    if (card.attackCooldown <= 0) {
      const newHp = Math.max(0, target.hp - card.damage);
      if (shouldSync(target.id, 250)) {
        card.attackCooldown = card.hitspeed;
        rtdb.ref(`battles/${matchCreator}/${matchId}/placements/${target.id}`)
          .update({ hp: newHp }).catch(console.error);
      }
    }
  });

  requestAnimationFrame(gameLoop);
}

auth.onAuthStateChanged(async user => {
  if (!user) {
    window.location.href = "index.html";
    return;
  }
  currentUser = user;
  await loadBattle();
  startPlacementListener();
  gameLoop();
});
</script>

</body>
</html>
