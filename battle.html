<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Clash Royale Clone - Battle</title>
<style>
  body, html {
    margin: 0; padding: 0; height: 100%; background: #181818; color: white; font-family: Arial, sans-serif;
    user-select: none;
    overflow: hidden;
  }
  #battleArea {
    position: relative;
    width: 100vw;
    height: 100vh;
    display: flex;
    flex-direction: column;
  }
  #map {
    flex-grow: 1;
    background: linear-gradient(to top, #0b5700 0%, #147b00 100%);
    position: relative;
    cursor: crosshair;
  }
  #map::before {
    content: "";
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    height: 3px;
    background: rgba(255, 255, 255, 0.2);
  }
  #hand {
    height: 140px;
    background: #222;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px;
    gap: 15px;
    box-shadow: 0 -5px 15px rgba(0,0,0,0.7);
  }
  .card {
    background: #444;
    border-radius: 12px;
    width: 80px;
    height: 110px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 24px;
    font-weight: bold;
    color: white;
    box-shadow: 0 3px 6px rgba(0,0,0,0.8);
    user-select: none;
    transition: transform 0.2s ease;
    cursor: pointer;
    position: relative;
  }
  .card.selected {
    outline: 3px solid #4caf50;
    transform: scale(1.1);
  }
  /* Placed cards on map */
  .placed-card {
    position: absolute;
    width: 60px;
    height: 80px;
    background: #4caf50cc;
    border-radius: 10px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    color: #fff;
    pointer-events: none;
    user-select: none;
  }
  .hp-bar-container {
    position: absolute;
    top: 5px;
    left: 50%;
    transform: translateX(-50%);
    width: 70%;
    height: 8px;
    background: #333;
    border-radius: 4px;
  }
  .hp-bar {
    height: 100%;
    background: #0f0;
    border-radius: 4px;
    width: 100%;
  }
  #startText {
    position: absolute;
    top: 10px;
    width: 100%;
    text-align: center;
    font-size: 22px;
    color: #0f0;
    pointer-events: none;
    user-select: none;
    z-index: 100;
  }
  /* Player names at top of map */
  #playerNames {
    position: absolute;
    top: 10px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    padding: 0 30px;
    font-size: 18px;
    color: white;
    pointer-events: none;
    user-select: none;
    z-index: 100;
  }
</style>
</head>
<body>
  <div id="startText"></div>
<div id="playerNames" style="display:flex; justify-content:space-between; width:800px; margin: 0 auto; color:white; font-weight:bold; font-size:18px; padding: 5px 10px;">
  <div id="player1Name">Player 1</div>
  <div id="player2Name">Player 2</div>
</div>
<div id="hand" style="display:flex; gap:10px; justify-content:center; margin: 10px auto; width:800px;"></div>
<div id="map" style="position:relative; width:800px; height:400px; border:1px solid #000; margin: 0 auto;"></div>


  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>

 <script>
// Firebase config and initialization
const firebaseConfig = {
  apiKey: "AIzaSyADqsChcYfhT_bAlQ1VWkrlga-oTJViz7U",
  authDomain: "clashroyaleclone-ae764.firebaseapp.com",
  projectId: "clashroyaleclone-ae764",
  storageBucket: "clashroyaleclone-ae764.appspot.com",
  messagingSenderId: "938364278081",
  appId: "1:938364278081:web:1c214bd66caef6d7567dc0",
  measurementId: "G-PT2GPP0JF5"
};

firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();

const hand = document.getElementById("hand");
const map = document.getElementById("map");
const startText = document.getElementById("startText");
const player1NameEl = document.getElementById("player1Name");
const player2NameEl = document.getElementById("player2Name");

let currentUser = null;
let playerSide = null;     // "player1" or "player2"
let enemySide = null;
let playerDeck = [];
let enemyDeck = [];
let selectedCardIndex = null;
let selectedCardData = null;

let placedCards = [];
let cardDataCache = {};    // cardId -> data cache

const lobbyId = localStorage.getItem("lobbyId");
if (!lobbyId) {
  alert("Lobby ID not found! Redirecting to home.");
  window.location.href = "home.html";
  throw new Error("No lobbyId found, stopping script.");
}

// Load card data from Firestore "cards" collection
async function loadCardData() {
  const cardsSnapshot = await db.collection("cards").get();  // <--- Fetch snapshot here
  cardsSnapshot.forEach(doc => {
    const id = doc.id.toLowerCase();
    const data = doc.data();
    cardDataCache[id] = {
      name: data.name || doc.id,
      hitpoints: data.hitpoints || 100,
      damage: data.damage || 10,
      targets: (data.targets || "ground").split(",").map(t => t.trim()),
      elixir: data.elixir || 1,
      bio: data.bio || "",
      count: data.count || 1,
      speed: data.speed || "medium",
      range: data.range || "melee",
      hitspeed: data.hitspeed || 1.0
    };
  });
  console.log("Card data loaded:", Object.keys(cardDataCache));
}


// Load both players’ decks and set sides
async function loadBattle() {
  startText.textContent = "Loading battle data...";

  try {
    const lobbySnap = await db.collection("lobbies").doc(lobbyId).get();
    const lobbyData = lobbySnap.data();

    if (!lobbyData || !Array.isArray(lobbyData.players) || lobbyData.players.length < 2) {
      startText.textContent = "❌ Waiting for opponent...";
      return;
    }

    const [uid1, uid2] = lobbyData.players;

    const [player1Snap, player2Snap] = await Promise.all([
      db.collection("players").doc(uid1).get(),
      db.collection("players").doc(uid2).get(),
    ]);

    const player1 = player1Snap.data();
    const player2 = player2Snap.data();

    player1NameEl.textContent = player1?.username || "Player 1";
    player2NameEl.textContent = player2?.username || "Player 2";

    if (currentUser.uid === uid1) {
      playerSide = "player1";
      enemySide = "player2";
      playerDeck = Array.isArray(player1?.deck) ? [...player1.deck] : [];
      enemyDeck = Array.isArray(player2?.deck) ? [...player2.deck] : [];
    } else if (currentUser.uid === uid2) {
      playerSide = "player2";
      enemySide = "player1";
      playerDeck = Array.isArray(player2?.deck) ? [...player2.deck] : [];
      enemyDeck = Array.isArray(player1?.deck) ? [...player1.deck] : [];
    } else {
      alert("You are not in this battle.");
      window.location.href = "home.html";
      return;
    }

    console.log("Player deck:", playerDeck);
    console.log("Enemy deck:", enemyDeck);

    await loadCardData();

    renderHand(playerDeck);
    renderEnemyHand(enemyDeck);

    startText.textContent = "✅ Battle Ready! Select a card and place it on your side.";

  } catch (err) {
    console.error(err);
    startText.textContent = "❌ Error loading battle.";
  }
}

function renderHand(deck) {
  hand.innerHTML = '';
  deck.forEach((cardId, idx) => {
    if (!cardId) {
      console.warn(`Skipping invalid cardId at index ${idx}:`, cardId);
      return;
    }
    const cardIdNormalized = cardId.toLowerCase();
    const cardData = cardDataCache[cardIdNormalized];
    if (!cardData) {
      console.warn(`Card data missing for cardId: ${cardId}`);
      return;
    }
    // rest of your rendering code
    const cardEl = document.createElement('div');
    cardEl.classList.add('card');
    cardEl.textContent = cardData.name || cardId;
    cardEl.title = `${cardData.name}\nHP: ${cardData.hitpoints}\nDamage: ${cardData.damage}\nTargets: ${cardData.targets.join(", ")}`;
    cardEl.dataset.idx = idx;
    cardEl.addEventListener('click', () => {
      if (selectedCardIndex === idx) {
        selectedCardIndex = null;
        selectedCardData = null;
      } else {
        selectedCardIndex = idx;
        selectedCardData = cardData;
      }
      updateHandSelection();
    });
    hand.appendChild(cardEl);
  });
  updateHandSelection();
}

   // Utility function to calculate distance between two points
function distance(x1, y1, x2, y2) {
  return Math.hypot(x2 - x1, y2 - y1);
}

// Find nearest enemy card within placedCards
function findTarget(card) {
  const enemies = placedCards.filter(c => c.owner !== card.owner && c.hp > 0);
  if (enemies.length === 0) return null;

  let nearest = null;
  let nearestDist = Infinity;
  enemies.forEach(enemy => {
    const dist = distance(card.x, card.y, enemy.x, enemy.y);
    if (dist < nearestDist) {
      nearestDist = dist;
      nearest = enemy;
    }
  });
  return nearest;
}

// Apply damage to a target card and update health bar UI
function applyDamage(target, damage) {
  target.hp -= damage;
  if (target.hp < 0) target.hp = 0;

  if (target.hpBarElement) {
    const hpPercent = (target.hp / target.maxHp) * 100;
    target.hpBarElement.style.width = hpPercent + "%";

    if (hpPercent < 30) {
      target.hpBarElement.style.backgroundColor = "#f00"; // red low hp
    } else if (hpPercent < 60) {
      target.hpBarElement.style.backgroundColor = "#ff9900"; // orange mid hp
    } else {
      target.hpBarElement.style.backgroundColor = "#0f0"; // green high hp
    }
  }

  if (target.hp === 0) {
    if (target.domElement) {
      target.domElement.style.opacity = "0.5"; // faded dead card
    }
  }
}


function updateHandSelection() {
  const cards = hand.querySelectorAll(".card");
  cards.forEach((cardEl, i) => {
    cardEl.classList.toggle("selected", i === selectedCardIndex);
  });
}

function renderEnemyHand(deck) {
  // Optionally show enemy cards somewhere, or keep internal for AI logic
  console.log("Enemy deck loaded with cards:", deck.length);
}
function startPlacementListener() {
  // Detach previous listener if any
  if (window.unsubscribePlacements) {
    window.unsubscribePlacements();
  }

  window.unsubscribePlacements = db.collection("lobbies")
    .doc(lobbyId)
    .collection("placements")
    .orderBy("createdAt")
    .onSnapshot(snapshot => {
      // Remove existing placed card DOM elements
      placedCards.forEach(p => {
        if (p.domElement && p.domElement.parentElement) {
          p.domElement.parentElement.removeChild(p.domElement);
        }
      });
      placedCards = [];

      // Render each placement document
      snapshot.forEach(doc => {
        const data = doc.data();
        renderPlacedCard(doc.id, data);
      });
    });
}

function renderPlacedCard(id, data) {
  const cardIdNormalized = data.cardId.toLowerCase();
  const cardData = cardDataCache[cardIdNormalized];
  if (!cardData) {
    console.warn(`Card data missing for cardId: ${data.cardId}`);
    return;
  }

  const cardEl = document.createElement("div");
  cardEl.className = "placed-card";
  cardEl.textContent = cardData.name || data.cardId;
  cardEl.style.position = "absolute";
  cardEl.style.left = `${data.x - 30}px`;
  cardEl.style.top = `${data.y - 40}px`;
  cardEl.style.zIndex = data.owner === playerSide ? 10 : 5;

  // HP bar container and bar
  const hpBarContainer = document.createElement("div");
  hpBarContainer.className = "hp-bar-container";

  const hpBar = document.createElement("div");
  hpBar.className = "hp-bar";

  hpBarContainer.appendChild(hpBar);
  cardEl.appendChild(hpBarContainer);

  map.appendChild(cardEl);

  placedCards.push({
    id,
    owner: data.owner,
    x: data.x,
    y: data.y,
    hp: data.hp,
    maxHp: data.maxHp,
    damage: data.damage,
    targets: data.targets,
    speed: parseSpeed(data.speed),
    range: parseRange(data.range),
    hitspeed: data.hitspeed,
    attackCooldown: 0,
    domElement: cardEl,
    hpBarElement: hpBar,
  });
}

// Utility parse functions for speed and range
function parseSpeed(speedStr) {
  switch ((speedStr || "").toLowerCase()) {
    case "slow": return 30;
    case "medium": return 60;
    case "fast": return 120;
    default:
      let n = parseFloat(speedStr);
      return isNaN(n) ? 60 : n;
  }
}

function parseRange(rangeStr) {
  switch ((rangeStr || "").toLowerCase()) {
    case "melee": return 40;
    case "short": return 80;
    case "medium": return 150;
    case "long": return 250;
    default:
      let n = parseFloat(rangeStr);
      return isNaN(n) ? 50 : n;
  }
}

// Place card on map when clicked
map.addEventListener("click", (e) => {
  if (selectedCardIndex === null || !selectedCardData) {
    startText.textContent = "Select a card first!";
    return;
  }

  const rect = map.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Restrict placement to player's side (example: top half for player1, bottom half for player2)
  if ((playerSide === "player1" && clickY > rect.height / 2) ||
      (playerSide === "player2" && clickY < rect.height / 2)) {
    startText.textContent = "Place cards only on your side!";
    return;
  }

  placeCardOnMap(playerDeck[selectedCardIndex], clickX, clickY);

// Clear selection after placing (deck update will come from Firestore listener)
selectedCardIndex = null;
selectedCardData = null;
startText.textContent = "Card placed! Select another card or wait for battle.";

});

function placeCardOnMap(cardId, x, y) {
  const cardData = cardDataCache[cardId.toLowerCase()];
  if (!cardData) return;

  const cardEl = document.createElement('div');
  cardEl.classList.add('placed-card');
  cardEl.textContent = cardData.name || cardId;
  cardEl.style.left = `${x - 30}px`;
  cardEl.style.top = `${y - 40}px`;

  // HP bar container and bar
  const hpBarContainer = document.createElement('div');
  hpBarContainer.className = 'hp-bar-container';

  const hpBar = document.createElement('div');
  hpBar.className = 'hp-bar';

  hpBarContainer.appendChild(hpBar);
  cardEl.appendChild(hpBarContainer);

  map.appendChild(cardEl);

  placedCards.push({
    id: cardId,
    owner: playerSide,
    x,
    y,
    hp: cardData.hitpoints,
    maxHp: cardData.hitpoints,
    damage: cardData.damage,
    targets: cardData.targets,
    speed: parseSpeed(cardData.speed),
    range: parseRange(cardData.range),
    hitspeed: cardData.hitspeed || 1.0,
    attackCooldown: 0,
    domElement: cardEl,
    hpBarElement: hpBar
  });
}


function distance(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}

function findTarget(attacker) {
  // Simple target-finding: first enemy card in range
  return placedCards.find(card =>
    card.owner !== attacker.owner &&
    card.hp > 0 &&
    distance(attacker.x, attacker.y, card.x, card.y) <= attacker.range
  );
}

let lastUpdateTime = performance.now();

function gameLoop() {
  const now = performance.now();
  const deltaTime = (now - lastUpdateTime) / 1000;
  lastUpdateTime = now;

  placedCards.forEach(card => {
    if (card.hp <= 0) return; // Skip dead cards

    // Reduce attack cooldown
    card.attackCooldown = Math.max(0, card.attackCooldown - deltaTime);

    // Find a target: enemy card with hp > 0
    const target = placedCards.find(c => c.owner !== card.owner && c.hp > 0);
    if (!target) return;

    const dx = target.x - card.x;
    const dy = target.y - card.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist > card.range) {
      // Move toward the target
      const angle = Math.atan2(dy, dx);
      const moveDist = Math.min(card.speed * deltaTime, dist - card.range);

      card.x += Math.cos(angle) * moveDist;
      card.y += Math.sin(angle) * moveDist;

      // Update DOM element position
      if (card.domElement) {
        card.domElement.style.left = `${card.x - 30}px`;
        card.domElement.style.top = `${card.y - 40}px`;
      }
    } else {
      // Within range, attack if cooldown ready
      if (card.attackCooldown === 0) {
        // Deal damage to target
        target.hp -= card.damage;
        if (target.hp < 0) target.hp = 0;

        // Reset attack cooldown
        card.attackCooldown = card.hitspeed;

        // Update target HP bar visually
        if (target.hpBarElement) {
          const hpPercent = (target.hp / target.maxHp) * 100;
          target.hpBarElement.style.width = `${hpPercent}%`;
          // Optional: change color based on HP left
          target.hpBarElement.style.backgroundColor = hpPercent < 30 ? "#f00" : "#0f0";
        }

        // Optional: log attacks
        console.log(`${card.id} attacks ${target.id} for ${card.damage} damage!`);
      }
    }
  });

  requestAnimationFrame(gameLoop);
}



auth.onAuthStateChanged(async (user) => {
  if (!user) {
    window.location.href = "index.html";
    return;
  }
  currentUser = user;
  await loadBattle();
  startPlacementListener(); // Adds the click listener here
  gameLoop();
});

</script>

</body>
</html>
