<!DOCTYPE html>
<html>
<head>
  <title>Deck Builder</title>
  <meta charset="UTF-8" />
  <style>
    /* styles preserved */
  </style>
</head>
<body>
  <h1>Deck Builder</h1>
  <p>Drag cards into the deck slots below (Max 6, no duplicates). You can also drag cards out of your deck back here.</p>
  <div class="card-container" id="cardContainer"></div>
  <h2>Your Deck</h2>
  <div class="deck-container" id="deckContainer"></div>
  <button onclick="goHome()">⬅️ Back to Home</button>
  <div id="notification"></div>

  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>

  <script>
    const ASSETS_BASE_URL = "https://brickbugs.github.io/clashroyaleclone-assets"; 
    const firebaseConfig = {
      apiKey: "AIzaSyADqsChcYfhT_bAlQ1VWkrlga-oTJViz7U",
      authDomain: "clashroyaleclone-ae764.firebaseapp.com",
      projectId: "clashroyaleclone-ae764",
      storageBucket: "clashroyaleclone-ae764.appspot.com",
      messagingSenderId: "938364278081",
      appId: "1:938364278081:web:1c214bd66caef6d7567dc0",
      measurementId: "G-PT2GPP0JF5"
    };

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    let cardList = [];
    let currentUser = null;
    let notificationTimeout = null;

    const cardContainer = document.getElementById("cardContainer");
    const deckContainer = document.getElementById("deckContainer");
    const notification = document.getElementById("notification");

    auth.onAuthStateChanged(async (user) => {
      if (!user) {
        window.location.href = "index.html";
        return;
      }
      currentUser = user;

      await loadCards();

      renderCards();
      renderDeckSlots();

      const doc = await db.collection("players").doc(user.uid).get();
      const data = doc.data() || {};
      const savedDeck = data.deck || [];

      for (let i = 0; i < 6; i++) {
        deckContainer.children[i].innerHTML = "";
      }

      for (let i = 0; i < savedDeck.length; i++) {
        if (savedDeck[i]) {
          if (!isCardInDeck(savedDeck[i])) {
            const cardObj = cardList.find(c => c.name === savedDeck[i]);
            if (cardObj) {
              const cardEl = createCard(cardObj);
              deckContainer.children[i].appendChild(cardEl);
            }
          }
        }
      }
    });

    async function loadCards() {
      try {
        const snapshot = await db.collection("cards").orderBy("name").get();
        cardList = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));
      } catch (err) {
        console.error("Error loading cards:", err);
        showNotification("Failed to load cards.");
      }
    }

    function showNotification(message) {
      notification.textContent = message;
      notification.classList.add("show");

      clearTimeout(notificationTimeout);
      notificationTimeout = setTimeout(() => {
        notification.classList.remove("show");
      }, 3000);
    }

    function renderCards() {
      cardContainer.innerHTML = "";
      cardList.forEach(card => {
        if (!isCardInDeck(card.name)) {
          const cardEl = createCard(card);
          cardContainer.appendChild(cardEl);
        }
      });

      cardContainer.ondragover = e => e.preventDefault();
      cardContainer.ondrop = e => {
        e.preventDefault();
        const cardName = e.dataTransfer.getData("text/plain");
        if (!cardName) return;

        if (!isCardInDeck(cardName)) {
          showNotification("This card is already in your available cards.");
          return;
        }

        removeCardFromDeck(cardName);
        renderCards();
        saveDeck();
      };
    }

    function renderDeckSlots() {
      deckContainer.innerHTML = "";
      for (let i = 0; i < 6; i++) {
        const slot = document.createElement("div");
        slot.className = "deck-slot";
        slot.dataset.index = i;

        slot.ondragover = e => e.preventDefault();
        slot.ondrop = e => {
          e.preventDefault();
          const cardName = e.dataTransfer.getData("text/plain");
          if (!cardName) return;

          if (isCardInDeck(cardName)) {
            showNotification("You already have this card in your deck!");
            return;
          }

          const existing = slot.querySelector(".card");
          if (existing) existing.remove();

          const cardObj = cardList.find(c => c.name === cardName);
          if (!cardObj) {
            showNotification("Card not found.");
            return;
          }

          const newCard = createCard(cardObj);
          slot.appendChild(newCard);

          newCard.style.transform = "scale(1.2)";
          setTimeout(() => {
            newCard.style.transform = "scale(1)";
          }, 300);

          renderCards();
          saveDeck();
        };

        deckContainer.appendChild(slot);
      }
    }

    function isCardInDeck(cardName) {
      for (let i = 0; i < deckContainer.children.length; i++) {
        const slot = deckContainer.children[i];
        const card = slot.querySelector(".card");
        if (card && card.dataset.name === cardName) return true;
      }
      return false;
    }

    function removeCardFromDeck(cardName) {
      for (let i = 0; i < deckContainer.children.length; i++) {
        const slot = deckContainer.children[i];
        const card = slot.querySelector(".card");
        if (card && card.dataset.name === cardName) {
          card.remove();
          break;
        }
      }
    }

    function createCard(card) {
      const div = document.createElement("div");
      div.className = "card";
      div.draggable = true;
      div.dataset.name = card.name;

      div.ondragstart = e => {
        e.dataTransfer.setData("text/plain", card.name);
      };

      const img = document.createElement("img");
      img.className = "card-icon";
      img.alt = card.name + " icon";

      if (card.assetFolder) {
        img.src = `${ASSETS_BASE_URL}/${card.assetFolder}/icon.png`;
      } else {
        img.src = "";
      }
      div.appendChild(img);

      const nameEl = document.createElement("div");
      nameEl.className = "card-name";
      nameEl.textContent = card.name;
      div.appendChild(nameEl);

      if (card.elixir !== undefined) {
        const elixirEl = document.createElement("div");
        elixirEl.className = "card-elixir";
        elixirEl.textContent = card.elixir;
        div.appendChild(elixirEl);
      }

      return div;
    }

    function saveDeck() {
      const deck = [];
      for (let i = 0; i < 6; i++) {
        const slot = deckContainer.children[i];
        const card = slot.querySelector(".card");
        deck.push(card ? card.dataset.name : null);
      }
      if (currentUser) {
        db.collection("players").doc(currentUser.uid).update({
          deck: deck
        }).catch(err => {
          console.error("Error saving deck:", err);
          showNotification("Error saving deck data.");
        });
      }
    }

    function goHome() {
      window.location.href = "home.html";
    }
  </script>
</body>
</html>
