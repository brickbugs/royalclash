<!DOCTYPE html>
<html>
<head>
  <title>Deck Builder</title>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #e3e3e3;
      padding: 20px;
      text-align: center;
      position: relative;
      margin: 0;
      min-height: 100vh;
      box-sizing: border-box;
    }
    h1 {
      margin-bottom: 10px;
      font-size: 1.6rem;
    }
    p {
      font-size: 1rem;
      max-width: 400px;
      margin-left: auto;
      margin-right: auto;
    }
    .card-container, .deck-container {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 20px;
      min-height: 120px;
      border: 2px dashed #888;
      padding: 10px;
      background-color: white;
      user-select: none;
      max-width: 100%;
      box-sizing: border-box;
    }
    .card, .deck-slot {
      width: 100px;
      height: 140px;
      border: 2px dashed #aaa;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      font-weight: bold;
      background-color: white;
      cursor: grab;
      user-select: none;
      transition: transform 0.3s ease;
      padding: 6px;
      box-sizing: border-box;
      position: relative;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.15);
      touch-action: manipulation;
    }
    .deck-slot {
      border-style: solid;
      background-color: #fdfdfd;
      cursor: pointer;
      /* For highlighting selected slot */
      transition: box-shadow 0.25s ease;
    }
    .deck-slot.selected {
      box-shadow: 0 0 12px 3px #1976d2;
      border-color: #1976d2;
    }
    .card-name {
      font-size: 16px;
      margin-top: 6px;
      user-select: none;
      text-align: center;
      pointer-events: none;
    }
    .card-elixir {
      background-color: #4caf50;
      color: white;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 14px;
      position: absolute;
      top: 6px;
      left: 6px;
      user-select: none;
      pointer-events: none;
      box-shadow: 0 0 4px rgba(0,0,0,0.3);
    }
    .card-icon {
      width: 64px;
      height: 64px;
      user-select: none;
      pointer-events: none;
      object-fit: contain;
      border-radius: 6px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.25);
    }
    button {
      margin-top: 30px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      user-select: none;
    }
    #notification {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #f44336;
      color: white;
      padding: 12px 24px;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
      z-index: 1000;
      font-weight: bold;
      user-select: none;
      max-width: 320px;
    }
    #notification.show {
      opacity: 1;
      pointer-events: auto;
    }

    /* Info button - hidden by default */
    .info-button {
      display: none;
      position: absolute;
      bottom: 5px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #1976d2;
      color: white;
      border: none;
      border-radius: 5px;
      padding: 4px 8px;
      font-size: 12px;
      cursor: pointer;
      z-index: 10;
      user-select: none;
    }

    /* Popup styling */
    #card-info-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      border: 2px solid #333;
      padding: 20px;
      border-radius: 10px;
      z-index: 2000;
      box-shadow: 0 5px 15px rgba(0,0,0,0.5);
      width: 320px;
      display: none;
      text-align: left;
      user-select: none;
    }
    #popup-content h3 {
      margin-bottom: 10px;
      text-align: center;
    }
    #popup-content p {
      margin: 6px 0;
      font-size: 14px;
    }
    #popup-content button {
      margin-top: 15px;
      padding: 8px 16px;
      background-color: #1976d2;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      display: block;
      margin-left: auto;
      margin-right: auto;
      user-select: none;
    }

    /* Responsive adjustments */
    @media (max-width: 480px) {
      .card, .deck-slot {
        width: 70px;
        height: 100px;
        padding: 4px;
      }
      .card-name {
        font-size: 12px;
      }
      .card-elixir {
        width: 22px;
        height: 22px;
        font-size: 12px;
        top: 4px;
        left: 4px;
      }
      .card-icon {
        width: 44px;
        height: 44px;
      }
      button {
        font-size: 14px;
        padding: 8px 16px;
      }
      h1 {
        font-size: 1.3rem;
      }
      p {
        font-size: 0.9rem;
        max-width: 320px;
      }
    }
  </style>
</head>
<body>
  <h1>Deck Builder</h1>
  <p>Drag cards into the deck slots below (Max 6, no duplicates). You can also drag cards out of your deck back here.<br>
  Or <strong>tap/click a card, then tap/click a deck slot</strong> to place it.</p>

  <div class="card-container" id="cardContainer"></div>
  <h2>Your Deck</h2>
  <div class="deck-container" id="deckContainer"></div>
  <button onclick="goHome()">⬅️ Back to Home</button>
  <div id="notification"></div>

  <!-- Info Popup -->
  <div id="card-info-popup">
    <div id="popup-content">
      <h3 id="popup-title">Card Info</h3>
      <p><strong>Hitpoints:</strong> <span id="popup-hp">N/A</span></p>
      <p><strong>Damage:</strong> <span id="popup-damage">N/A</span></p>
      <p><strong>Elixir Cost:</strong> <span id="popup-elixr">N/A</span></p>
      <p><strong>Upgrade Cost:</strong> <span id="popup-upgrade">N/A</span></p>
      <p><strong>Bio:</strong> <span id="popup-bio">No bio available.</span></p>
      <p><strong>Count:</strong> <span id="popup-count">N/A</span></p>
      <p><strong>Targets:</strong> <span id="popup-targets">N/A</span></p>
      <p><strong>Speed:</strong> <span id="popup-speed">N/A</span></p>
      <p><strong>Range:</strong> <span id="popup-range">N/A</span></p>
      <p><strong>Hit Speed:</strong> <span id="popup-hitspeed">N/A</span></p>
      <button onclick="closeCardInfo()">Close</button>
    </div>
  </div>

  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>

  <script>
    const ASSETS_BASE_URL = "https://brickbugs.github.io/clashroyaleclone-assets";
    const firebaseConfig = {
      apiKey: "AIzaSyADqsChcYfhT_bAlQ1VWkrlga-oTJViz7U",
      authDomain: "clashroyaleclone-ae764.firebaseapp.com",
      projectId: "clashroyaleclone-ae764",
      storageBucket: "clashroyaleclone-ae764.appspot.com",
      messagingSenderId: "938364278081",
      appId: "1:938364278081:web:1c214bd66caef6d7567dc0",
      measurementId: "G-PT2GPP0JF5"
    };

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    let cardList = [];
    let currentUser = null;
    let notificationTimeout = null;

    const cardContainer = document.getElementById("cardContainer");
    const deckContainer = document.getElementById("deckContainer");
    const notification = document.getElementById("notification");

    // State for click-to-place mode
    let selectedCardName = null;

   auth.onAuthStateChanged(async (user) => {
  if (!user) {
    window.location.href = "index.html";
    return;
  }
  currentUser = user;

  await loadCards();
  renderDeckSlots();

  const playerRef = db.collection("players").doc(user.uid);
  const playerDoc = await playerRef.get();
  const playerData = playerDoc.data() || {};

  const savedDeck = playerData.deck || [];
  const ownedCards = new Set(playerData.cards || []);

  // Find any new cards the player doesn't own yet
  const newCards = cardList
    .map(card => card.name)
    .filter(name => !ownedCards.has(name));

  // If any new cards were found, add them to the user's inventory
  if (newCards.length > 0) {
    newCards.forEach(name => ownedCards.add(name));
    await playerRef.update({
      cards: Array.from(ownedCards)
    });
  }

  // Load current deck cards
  for (let i = 0; i < savedDeck.length; i++) {
    const cardName = savedDeck[i];
    const slot = deckContainer.children[i];

    if (cardName) {
      const cardObj = cardList.find(c => c.name === cardName);
      if (cardObj) {
        const cardEl = createCard(cardObj);
        slot.appendChild(cardEl);
      }
    }
  }

  renderCards();
});

    async function loadCards() {
      try {
        const snapshot = await db.collection("cards").orderBy("name").get();
        cardList = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));
      } catch (err) {
        console.error("Error loading cards:", err);
        showNotification("Failed to load cards.");
      }
    }

    function showNotification(message) {
      notification.textContent = message;
      notification.classList.add("show");
      clearTimeout(notificationTimeout);
      notificationTimeout = setTimeout(() => {
        notification.classList.remove("show");
      }, 3000);
    }

    function renderCards() {
      cardContainer.innerHTML = "";
      const deckedCards = getDeckCardNames();

      cardList.forEach(card => {
        if (!deckedCards.includes(card.name)) {
          const cardEl = createCard(card);
          cardContainer.appendChild(cardEl);
        }
      });

      // Drag & drop for card container
      cardContainer.ondragover = e => e.preventDefault();
      cardContainer.ondrop = e => {
        e.preventDefault();
        const cardName = e.dataTransfer.getData("text/plain");
        if (!cardName) return;

        removeCardFromDeck(cardName);
        clearSelection();
        renderCards();
        saveDeck();
      };
    }

    function getDeckCardNames() {
      const names = [];
      for (let i = 0; i < deckContainer.children.length; i++) {
        const slot = deckContainer.children[i];
        const card = slot.querySelector(".card");
        if (card) names.push(card.dataset.name);
      }
      return names;
    }

    function renderDeckSlots() {
      deckContainer.innerHTML = "";
      for (let i = 0; i < 6; i++) {
        const slot = document.createElement("div");
        slot.className = "deck-slot";
        slot.dataset.index = i;

        slot.ondragover = e => e.preventDefault();
        slot.ondrop = e => {
          e.preventDefault();
          const cardName = e.dataTransfer.getData("text/plain");
          if (!cardName) return;

          if (isCardInDeck(cardName)) {
            showNotification("You already have this card in your deck!");
            return;
          }

          const existing = slot.querySelector(".card");
          if (existing) existing.remove();

          const cardObj = cardList.find(c => c.name === cardName);
          if (!cardObj) {
            showNotification("Card not found.");
            return;
          }

          const newCard = createCard(cardObj);
          slot.appendChild(newCard);

          newCard.style.transform = "scale(1.2)";
          setTimeout(() => {
            newCard.style.transform = "scale(1)";
          }, 300);

          clearSelection();
          renderCards();
          saveDeck();
        };

        // Click to place selected card logic
        slot.addEventListener("click", () => {
          if (selectedCardName) {
            if (isCardInDeck(selectedCardName)) {
              showNotification("You already have this card in your deck!");
              clearSelection();
              return;
            }

            const existing = slot.querySelector(".card");
            if (existing) existing.remove();

            const cardObj = cardList.find(c => c.name === selectedCardName);
            if (!cardObj) {
              showNotification("Card not found.");
              clearSelection();
              return;
            }

            const newCard = createCard(cardObj);
            slot.appendChild(newCard);

            newCard.style.transform = "scale(1.2)";
            setTimeout(() => {
              newCard.style.transform = "scale(1)";
            }, 300);

            clearSelection();
            renderCards();
            saveDeck();
          }
        });

        deckContainer.appendChild(slot);
      }
    }

    function isCardInDeck(cardName) {
      return getDeckCardNames().includes(cardName);
    }

    function removeCardFromDeck(cardName) {
      for (let i = 0; i < deckContainer.children.length; i++) {
        const slot = deckContainer.children[i];
        const card = slot.querySelector(".card");
        if (card && card.dataset.name === cardName) {
          card.remove();
          break;
        }
      }
    }

    function createCard(card) {
      const div = document.createElement("div");
      div.className = "card";
      div.draggable = true;
      div.dataset.name = card.name;

      div.ondragstart = e => {
        e.dataTransfer.setData("text/plain", card.name);
      };

      const img = document.createElement("img");
      img.className = "card-icon";
      img.alt = card.name + " icon";
      img.src = card.assetFolder ? `${ASSETS_BASE_URL}/${card.assetFolder}/icon.png` : "";
      div.appendChild(img);

      const nameEl = document.createElement("div");
      nameEl.className = "card-name";
      nameEl.textContent = card.name;
      div.appendChild(nameEl);

      if (card.elixir !== undefined) {
        const elixirEl = document.createElement("div");
        elixirEl.className = "card-elixir";
        elixirEl.textContent = card.elixir;
        div.appendChild(elixirEl);
      }

      const infoBtn = document.createElement("button");
      infoBtn.className = "info-button";
      infoBtn.textContent = "Info";

      // Info button click: show card info popup
      infoBtn.addEventListener("click", async (e) => {
        e.stopPropagation(); // Prevent card click toggle
        await showCardInfo(card.name);
      });

      div.appendChild(infoBtn);

      // Show info button on card click, hide others
      div.addEventListener("click", (e) => {
        e.stopPropagation();

        // If this card is already selected for click-to-place, deselect it
        if (selectedCardName === card.name) {
          clearSelection();
          return;
        }

        // Select this card for click-to-place
        selectedCardName = card.name;

        // Visual feedback: highlight selected card
        document.querySelectorAll(".card").forEach(c => {
          c.style.borderColor = c.dataset.name === selectedCardName ? "#1976d2" : "#aaa";
          c.style.boxShadow = c.dataset.name === selectedCardName ? "0 0 10px 3px #1976d2" : "0 2px 5px rgba(0,0,0,0.15)";
        });

        // Show info button only on selected card
        document.querySelectorAll(".info-button").forEach(btn => btn.style.display = "none");
        infoBtn.style.display = "block";

        // Highlight deck slots to indicate they are clickable
        deckContainer.querySelectorAll(".deck-slot").forEach(slot => {
          slot.classList.add("selected");
        });
      });

      return div;
    }

    function clearSelection() {
      selectedCardName = null;
      // Remove highlights from cards
      document.querySelectorAll(".card").forEach(c => {
        c.style.borderColor = "#aaa";
        c.style.boxShadow = "0 2px 5px rgba(0,0,0,0.15)";
      });
      // Hide all info buttons
      document.querySelectorAll(".info-button").forEach(btn => btn.style.display = "none");
      // Remove highlights from deck slots
      deckContainer.querySelectorAll(".deck-slot").forEach(slot => {
        slot.classList.remove("selected");
      });
    }

    async function showCardInfo(cardName) {
      try {
        const querySnapshot = await db.collection("cards").where("name", "==", cardName).limit(1).get();
        if (!querySnapshot.empty) {
          const cardData = querySnapshot.docs[0].data();

          document.getElementById("popup-title").textContent = cardData.name || cardName;
          document.getElementById("popup-hp").textContent = cardData.hitpoints ?? "N/A";
          document.getElementById("popup-damage").textContent = cardData.damage ?? "N/A";
          document.getElementById("popup-elixr").textContent = cardData.elixir ?? "N/A";
          document.getElementById("popup-upgrade").textContent = cardData.upgradeCost ?? "N/A";
          document.getElementById("popup-bio").textContent = cardData.bio || "No bio available.";
          document.getElementById("popup-count").textContent = cardData.count ?? "N/A";
          document.getElementById("popup-targets").textContent = cardData.targets ?? "N/A";
          document.getElementById("popup-speed").textContent = cardData.speed ?? "N/A";
          document.getElementById("popup-range").textContent = cardData.range ?? "N/A";
          document.getElementById("popup-hitspeed").textContent = cardData.hitspeed ?? "N/A";

          document.getElementById("card-info-popup").style.display = "block";
        } else {
          showNotification("Card info not found.");
        }
      } catch (error) {
        console.error("Error getting card info:", error);
        showNotification("Failed to load card info.");
      }
    }

    function closeCardInfo() {
      document.getElementById("card-info-popup").style.display = "none";
    }

    // Hide info buttons and clear selection if clicking outside cards or slots
    document.addEventListener("click", (e) => {
      // If click is NOT on a card or deck slot or info button, clear selection and hide info buttons
      if (
        !e.target.closest(".card") &&
        !e.target.closest(".deck-slot") &&
        !e.target.closest(".info-button") &&
        !e.target.closest("#card-info-popup")
      ) {
        clearSelection();
      }
    });

    function saveDeck() {
      const deck = [];
      for (let i = 0; i < 6; i++) {
        const slot = deckContainer.children[i];
        const card = slot.querySelector(".card");
        deck.push(card ? card.dataset.name : null);
      }
      if (currentUser) {
        db.collection("players").doc(currentUser.uid).update({ deck }).catch(err => {
          console.error("Error saving deck:", err);
          showNotification("Error saving deck data.");
        });
      }
    }

    function goHome() {
      window.location.href = "home.html";
    }
  </script>
</body>
</html>
